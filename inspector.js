/* 
 Inspects the code topology of a JavaScript application
 */

//var request = require("request");
//var npm = require('npm');
var fs = require('fs'),
	esprima = require('esprima');


// The high-level function that handles fetching the code, file i/o, concatenating things
// and perhaps interacting with some kind of callback passed in from a server file.
function getGraph( filePath, callback ) {
	fs.readFile( filePath, 'utf8', function( err, data ) {
		if (err) {
			console.error( 'There was an error reading the file.' );
		}
		var pt = esprima.parse( data ),
			names = tokensToNames( pt );			// TODO do some error handling before calling this
			result = analyzeNames( names );			// TODO and some error handling here too
		// TODO do something with the graph - call a callback
		callback( result );
	});
}



// From a raw list of tokens generated by Esprima, extract the identifiers and return a hash
// with their counts.
function tokensToNames( syntaxTree ) {
	
	var names = {};

	function add( name ) {
		if (!names.hasOwnProperty( name )) names[ name ] = 0;
		names[ name ]++;
	}

	(function getNames( st ) {
		if (!st || !st.body) return;
		var node;
		for ( var i = 0, len = st.body.length; i < len; i++ ) {
			node = st.body[i];
			if ( !node.type ) continue;
			switch( node.type ) {
				case "FunctionDeclaration":
					add( node.id.name );
					for ( var j = 0, pLen = node.params.length; j < pLen; j++ ) {
						add( node.params[j].name );
					}
					getNames( node.body );
					break;
				case "VariableDeclaration":
					var dec;
					for ( var k = 0, dLen = node.declarations.length; k < dLen; k++ ) {
						dec = node.declarations[k];
						if ( dec.type === "VariableDeclarator" ) {
							add( dec.id.name );
						}
						getNames( dec.body );
					}
					break;
				case "ForStatement":
					for ( var m = 0, iLen = node.init.declarations.length; m < iLen; m++ ) {
						add( node.init.declarations[m].id.name );
					}
					getNames( node.body );
					break;
				case "ExpressionStatement":
					// For the time being only process function expressions in this case
					if ( node.expression.right &&
					     node.expression.right.type === "FunctionExpression" ) {
						add( node.expression.left.property.name );
						for ( var n = 0, nLen = node.expression.right.params.length; n < nLen; n++ ) {
							add( node.expression.right.params[n].name );
						}
						getNames( node.expression.right.body );
					}
					break;
			}
		}
	})( syntaxTree );

	return names;	
}


/*
   Analyzes the names for various characteristics.
 */
function analyzeNames( names ) {

	var attributes = {

		nameFrequencyMean: 0,	// Median number of times a name is used
		wordFrequencyMean: 0,	// Median number of times a word within a name is used
		wordCountMean: 0,		// Average number of individual words
		nameLengthMean: 0,		// Average number of characters
		wordLengthMean: 0,		// Average number of characters in the individual words
		cameliness: 0,			// How well do you follow camelCase convention?
		commoness: 0,			// How heavily do you use common English words?
		partsToWhole: 0			// How much do you reuse common fragments of names (individual words)?

	};
	
	var namePart, partCount,
		nameCount = Object.keys( names ).length,
		totalPartCount = 0,
		totalNameLength = 0,
		totalPartLength = 0,
		partCountsByName = {},
		words = {};
	
	for ( var name in names ) {

		nameParts = getNameParts( name );
		partCount = nameParts.length;
		
		partCountsByName[ name ] = partCount;

		totalPartCount += partCount;
		totalNameLength += name.length;

		for ( var i = 0, len = partCount; i < len; i++ ) {
			namePart = nameParts[i];
			if ( !words.hasOwnProperty( namePart ) ) words[ namePart ] = 0;
			words[ namePart ]++;
		}
	}

	var partCount = Object.keys( words ).length;

	for ( var word in words ) {
		totalPartLength += word.length;
	}
	
	var nameCounts = getValues( names ),
		wordCounts = getValues( words ),
		partCounts = getValues( partCountsByName ),
		nameLengths = Object.keys( names ).map(function(key){ return key.length }),
		wordLengths = Object.keys( words ).map(function(key){ return key.length });

	attributes.nameFrequencyMean = calcMean( nameCounts );
	attributes.wordFrequencyMean = calcMean( wordCounts );
	attributes.wordCountMean = totalPartCount / nameCount;
	attributes.nameLengthMean = totalNameLength / nameCount;
	attributes.wordLengthMean = totalPartLength / partCount;

	attributes.nameFrequencyVariance = calcVariance( nameCounts, attributes.nameFrequencyMean );
	attributes.wordFrequencyVariance = calcVariance( wordCounts, attributes.wordFrequencyMean );
	attributes.wordCountVariance = calcVariance( partCounts, attributes.wordCountMean );
	attributes.nameLengthVariance = calcVariance( nameLengths, attributes.nameLengthMean );
	attributes.wordLengthVariance = calcVariance( wordLengths, attributes.wordLengthMean );

	return { attributes: attributes }//, identifiers: names };
}


/*
	Calculates the mean value of the values
 */
function calcMean( values ) {
	var total = 0;
	for ( var i = 0, len = values.length; i < len; i++ ) total += values[i];
	return total / values.length;
}


/*
	Calculates the variance of the values
 */
function calcVariance( values, mean ) {
	var mean = mean || calcMean( values ),
		squares = [];
	for ( var i = 0, len = values.length; i < len; i++ ) {
		squares.push( Math.pow( ( values[i] - mean ), 2 ) );
	}
	return calcMean( squares );
}





/*
   Returns the words that make up a name, or at least tries to
	Parameters:
	 	name -- the name to be preocessed
	Returns:
		An array of name parts
 */
function getNameParts( name ) {
	// Don't bother trying to break up really short names
	if ( name.length <= 3 ) {
		return [ name ]
	}
	var parts = [];
	// Check for some special conditions and handle them
	if ( name.search(/[a-z]/) < 0 ) {
		// If there are no lowercase characters then convert everything to lowercase
		name = name.toLowerCase();
		// Or if it's snake case
		// Ignoring names that start with underscore (should check for double underscore?)
		if ( name.search(/_/) < 0 ) {
			// If it's all uppercase and has no underscore then treat it as one word
			return [ name ];
		}
	} else {
		// If it's not all uppercase, then extract blocks of all caps characters, such as found
		// in names like 'someURL' or 'getXMLDocument' 
		var caps = name.match(/[A-Z]{2,}/g);
		if ( caps ) {
			var acronym;
			for ( var i = 0, len = caps.length; i < len; i++ ) {
				if ( name.search( new RegExp( caps[i] ) ) + caps[i].length === name.length ) {
					acronym = caps[i];
				} else {
					acronym = caps[i].slice(0,-1);
				}
				parts.push( acronym.toLowerCase() );
				name = name.replace( acronym, "" );
			}
		}
	}
	// Strip off leading underscores
	if ( name[0] === "_" ) name = name.slice(1);
	// Main iteration over the string to split it up into parts
	var shouldSplit,
		s = 0;
	for ( var i = 1, len = name.length; i < len; i++ ) {
		shouldSplit = false;
		if ( name[i].search(/[A-Z]/) >= 0 ) {
			shouldSplit = true;
			splitOffset = 0;
		} else if ( name[i] === "_" ) {
			shouldSplit = true;
			splitOffset = 1;
		} 
		if ( shouldSplit ) {
			parts.push( name.slice( s, i ).toLowerCase() );
			s = i + splitOffset;	// Ignore underscores
		}
	}
	// Add the last portion of the name to the parts array
	var lastPart = name.slice( s, i );
	if ( lastPart !== "" ) parts.push( lastPart.toLowerCase() );
	return parts
}


// Returns an array of the values within an object
function getValues( obj ) {
	var vals = [];
	for ( var key in obj ) { vals.push( obj[key] ) }
	return vals;
}


/*
 	Calculates the median value of the keys.
 	NOT SURE IF THIS IS NEEDED ANY MORE
 */
function calcMedianFrequency( entities ) {
	
	var median,
		valLen = 0,
		vals = getValues( entities );

	vals.sort();
	valLen = vals.length;
	if ( valLen & 1 === 0 ) {
		var half = valLen / 2;
		return ( vals[ half ] + vals[ half - 1 ] ) / 2;
	} else {
		return vals[ parseInt( valLen / 2 ) ];
	}
	return median;
}



module.exports = {
	getGraph: getGraph,
	tokensToNames: tokensToNames,
	analyzeNames: analyzeNames,
	getNameParts: getNameParts
}


//var fpath = '/Users/ske/js/playground/codetopo/tmp/helloworld/parser.js'
// var fpath = '/Users/ske/ui/github.com/Aditazz/room_library_synthesis-web-ui/room_library_synthesis/support_js/adi_rls_uimanager_library.js'
// getGraph( fpath, function( results ) {
// 	console.log( JSON.stringify( results ) );
// });
