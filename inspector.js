/**
	Inspects how things are named in a JavaScript application.
 */

var fs = require('fs'),
	esprima = require('esprima');


/** 
	The high-level function that handles fetching the code, file i/o, concatenating things
 	and perhaps interacting with some kind of callback passed in from a server file.
 	@param {string} dirPath 	- The path to the root directory of the source files you wan to process
 	@param {function} callback	- A callback function to be called once the file has been parsed
 								  and analyzed.  THe results of the analysis are passed to the callback
 */
function getAnalysis( dirPath, callback ) {

	var files = [],
		names = {};

	// Walk the directory tree and update the names data structure.
	// Doing everything syncronously because it's easier
	(function getJSFiles( dPath ) {
		var names = fs.readdirSync( dPath );
		for ( var i = 0, len = names.length; i < len; i++ ) {
			if ( shouldAnalyze( names[i] ) ) {
			//if ( names[i].slice(-3) === '.js' ) {
				files.push( dPath + '/' + names[i] );
			} else {
				var stat = fs.statSync( dPath + '/' + names[i] );
				if ( stat.isDirectory() && shouldExplore( names[i] ) ) {
					getJSFiles( dPath + '/' + names[i] )
				} 
			}
		}
	})( dirPath );

	var pt,
		fileCount = files.length,
		parsedCount = 0;

	// Now iterate over the collection of file paths and analyze them
	for ( var i = 0; i < fileCount; i++ ) {
		// Just creating a closure here to preserve the file path info
		(function( filePath ) {
			fs.readFile( filePath, 'utf8', function(err, data) {
				if (err) {
					console.log( 'There was an error reading the file ' + filePath );
					console.log( err );
					return;
				}
				try {
					pt = esprima.parse( data );
				} catch( e ) {
					console.log( 'Error parsing ' + filePath + '. Not including it in analysis.' );
					parsedCount++;	// Increment this anyway, since we want to reach the end condition
					return;
				}
				names = tokensToNames( pt, names );
				parsedCount++;
				if ( parsedCount === fileCount ) {
					// Finally analyze the names and call the callback if all the files have been parsed
					var result = analyzeNames( names );
					if ( result ) {
						result.packageDirectory = dirPath;
						callback( result );	
					}
				}
			});
		})( files[i] );
	}
}


// Helper function containing logic for whether or not analyze a given file
function shouldAnalyze( name ) {
	if ( name.slice(-3) === '.js' && name.search(/.min/) < 0 ) {
		return true;
	}
	return false;
}


// Helper function that contains logic for whether or not to traverse a given
// directory looking for JavaScript source files, based on its name
function shouldExplore( name ) {
	var skipNames = ['bin', 'examples', 'example', 'doc', 'docs', 'test', 'tests', 
				     'node_modules', 'release', 'templates' ];
	for ( var i = 0, len = skipNames.length; i < len; i++ ) {
		if ( name === skipNames[i] ) return false;
	}
	return true;
}


/**
	From a raw list of tokens generated by Esprima, extract the identifiers and return a hash
	with their counts.
	@param {Object} syntaxTree - A syntax tree object as returned by esprima's parse method
	@param {Object}	existingNames	- An object containing names and counts, which will be added to
									  when processesing the syntax tree. 
 */
function tokensToNames( syntaxTree, existingNames ) {
	
	var names = existingNames || {};

	function add( name ) {
		if (!names.hasOwnProperty( name )) names[ name ] = 0;
		names[ name ]++;
	}

	(function getNames( st ) {
		if (!st || !st.body) return;
		var node;
		for ( var i = 0, len = st.body.length; i < len; i++ ) {
			node = st.body[i];
			if ( !node.type ) continue;
			switch( node.type ) {
				case "FunctionDeclaration":
					add( node.id.name );
					for ( var j = 0, pLen = node.params.length; j < pLen; j++ ) {
						add( node.params[j].name );
					}
					getNames( node.body );
					break;
				case "VariableDeclaration":
					var dec;
					for ( var k = 0, dLen = node.declarations.length; k < dLen; k++ ) {
						dec = node.declarations[k];
						if ( dec.type === "VariableDeclarator" ) {
							add( dec.id.name );
						}
						getNames( dec.body );
					}
					break;
				case "ForStatement":
					if ( node.init && node.init.type === 'VariableDeclaration' ) {			
						for ( var m = 0, iLen = node.init.declarations.length; m < iLen; m++ ) {
							add( node.init.declarations[m].id.name );
						}
					}
					getNames( node.body );
					break;
				case "ExpressionStatement":
					// For the time being only process function expressions in this case
					if ( node.expression.right &&
					     node.expression.right.type === "FunctionExpression" ) {
						if ( node.expression.left.property ) {
							add( node.expression.left.property.name );
						}
						for ( var n = 0, nLen = node.expression.right.params.length; n < nLen; n++ ) {
							add( node.expression.right.params[n].name );
						}
						getNames( node.expression.right.body );
					}
					break;
			}
		}
	})( syntaxTree );

	return names;	
}


/**
   Analyzes the names for various characteristics.
   @param {Object} names 	- An object containing names that map to the number of times
   							  that name is used
   @returns {Object}		- Contains the data about the names
 */
function analyzeNames( names ) {

	var attributes = {

		nameFrequencyMean: 0,	// Median number of times a name is used
		wordFrequencyMean: 0,	// Median number of times a word within a name is used
		wordCountMean: 0,		// Average number of individual words
		nameLengthMean: 0,		// Average number of characters
		wordLengthMean: 0,		// Average number of characters in the individual words
		cameliness: 0,			// How well do you follow camelCase convention?
		commoness: 0,			// How heavily do you use common English words?
		partsToWhole: 0,		// How much do you reuse common fragments of names (individual words)?
		top10Names: [],
		top10Words: []
	};
	
	var namePart, partCount,
		sortedNames = sortByVals( names ),
		nameCount = sortedNames.length,
		totalPartCount = 0,
		totalNameLength = 0,
		totalPartLength = 0,
		partCountsByName = {},
		words = {};
	
	// Process each of the names passed in to the function, breaking each
	// name into its parts and keeping track of the parts
	for ( var name in names ) {

		nameParts = getNameParts( name );
		partCount = nameParts.length;

		partCountsByName[ name ] = partCount;

		totalPartCount += partCount;
		totalNameLength += name.length;

		for ( var i = 0, len = partCount; i < len; i++ ) {
			namePart = nameParts[i];
			if ( !words.hasOwnProperty( namePart ) ) words[ namePart ] = 0;
			words[ namePart ] += names[name];
		}
	}

	var sortedWords = sortByVals( words ),
		partCount = sortedWords.length;

	for ( var word in words ) {
		totalPartLength += word.length;
	}
	
	var nameCounts = getValues( names ),
		wordCounts = getValues( words ),
		partCounts = getValues( partCountsByName ),
		nameLengths = Object.keys( names ).map(function(key){ return key.length }),
		wordLengths = Object.keys( words ).map(function(key){ return key.length });

	attributes.nameFrequencyMean = calcMean( nameCounts );
	attributes.wordFrequencyMean = calcMean( wordCounts );
	attributes.wordCountMean = totalPartCount / nameCount;
	attributes.nameLengthMean = totalNameLength / nameCount;
	attributes.wordLengthMean = totalPartLength / partCount;

	attributes.nameFrequencyVariance = calcVariance( nameCounts, attributes.nameFrequencyMean );
	attributes.wordFrequencyVariance = calcVariance( wordCounts, attributes.wordFrequencyMean );
	attributes.wordCountVariance = calcVariance( partCounts, attributes.wordCountMean );
	attributes.nameLengthVariance = calcVariance( nameLengths, attributes.nameLengthMean );
	attributes.wordLengthVariance = calcVariance( wordLengths, attributes.wordLengthMean );

	attributes.top10Names = sortedNames.slice(0,10);
	attributes.top10Words = sortedWords.slice(0,10);

	return { attributes: attributes }//, identifiers: names };
}


// Calculates the mean value of the values
function calcMean( values ) {
	var total = 0;
	for ( var i = 0, len = values.length; i < len; i++ ) total += values[i];
	return total / values.length;
}


// Calculates the variance of the values
function calcVariance( values, mean ) {
	var mean = mean || calcMean( values ),
		squares = [];
	for ( var i = 0, len = values.length; i < len; i++ ) {
		squares.push( Math.pow( ( values[i] - mean ), 2 ) );
	}
	return calcMean( squares );
}


/**
	Returns the words that make up a name, or at least tries to
	@param {String} name 	- The name to be preocessed
	@returns {Array}		- An array of name parts
 */
function getNameParts( name ) {
	// Don't bother trying to break up really short names
	if ( name.length <= 3 ) {
		return [ name ]
	}
	var parts = [];
	// Check for some special conditions and handle them
	if ( name.search(/[a-z]/) < 0 ) {
		// If there are no lowercase characters then convert everything to lowercase
		name = name.toLowerCase();
		// Or if it's snake case
		// Ignoring names that start with underscore (should check for double underscore?)
		if ( name.search(/_/) < 0 ) {
			// If it's all uppercase and has no underscore then treat it as one word
			return [ name ];
		}
	} else {
		// If it's not all uppercase, then extract blocks of all caps characters, such as found
		// in names like 'someURL' or 'getXMLDocument' 
		var caps = name.match(/[A-Z]{2,}/g);
		if ( caps ) {
			var acronym;
			for ( var i = 0, len = caps.length; i < len; i++ ) {
				if ( name.search( new RegExp( caps[i] ) ) + caps[i].length === name.length ) {
					acronym = caps[i];
				} else {
					acronym = caps[i].slice(0,-1);
				}
				parts.push( acronym.toLowerCase() );
				name = name.replace( acronym, "" );
			}
		}
	}
	// Strip off leading underscores
	if ( name[0] === "_" ) name = name.slice(1);
	// Main iteration over the string to split it up into parts
	var shouldSplit,
		s = 0;
	for ( var i = 1, len = name.length; i < len; i++ ) {
		shouldSplit = false;
		if ( name[i].search(/[A-Z]/) >= 0 ) {
			shouldSplit = true;
			splitOffset = 0;
		} else if ( name[i] === "_" ) {
			shouldSplit = true;
			splitOffset = 1;
		} 
		if ( shouldSplit ) {
			parts.push( name.slice( s, i ).toLowerCase() );
			s = i + splitOffset;	// Ignore underscores
		}
	}
	// Add the last portion of the name to the parts array
	var lastPart = name.slice( s, i );
	if ( lastPart !== "" ) parts.push( lastPart.toLowerCase() );
	return parts
}


// Returns an array of the values within an object
function getValues( obj ) {
	var vals = [];
	for ( var key in obj ) { vals.push( obj[key] ) }
	return vals;
}

// Returns a sorted array of the keys in the object, sorted
// by the size of the value from biggest to smallest
function sortByVals( obj ) {
	var vals = [],
		keys = Object.keys( obj );
	keys.sort( function( a, b ) {
		if ( obj[b] > obj[a] ) return 1;
		if ( obj[a] === obj[b] ) return 0;
		return -1;
	});
	for ( var i = 0, len = keys.length; i < len; i++ ) {
		vals.push( [ keys[i], obj[ keys[i] ] ] );
	}
	return vals;
}


module.exports = {
	getAnalysis: getAnalysis,
	tokensToNames: tokensToNames,
	analyzeNames: analyzeNames,
	getNameParts: getNameParts
}


